# Javascript的工作原理

###  执行上下文 - 变量提升

```text
console.log(a)  // undefined
console.log(gen)  // f gen() {}

function gen() {
  console.log('gen: ', arguments)
}

var a = 'hello world'
```

如上述代码打印，在JS中，函数和变量是可以在声明之前访问的。

误区：变量提升 =&gt; 在执行代码的过程中，JS引擎将变量声明及函数声明部分提升到代码开头的行为。提升后，变量默认值为undefined，函数默认值为函数本身。

**实际上，变量和函数声明在代码中的位置是不会发生变化的，而是在编译阶段被JS引擎放入内存中。JS在执行的过程中，会进行分词，语法分析，构建AST抽象语法树，然后会创建执行上下文。变量、this、arguments等数据都是在执行上下文中。在上下文中的变量环境中存放提升的变量。**

上述代码分析：

1. 编译时，遇到两个console，由于不是声明，JS引擎不做提升处理，会将代码编译成字节码。
2. 遇到 f gen\(\) {} 时，会在堆中声明一块内存，存放函数的定义，并且在执行上下文中的变量环境中创建一个 gen 属性，该属性指向堆中的函数位置。
3. 遇到变量a时，在上下文的变量环境中创建一个名为 a 的属性，并且初始值为undefined。
4. 执行时，由于变量 a 还未赋值，所以打印 undefined。查找 gen 变量时，会在变量环境中找到 gen 属性，由于栈中存在函数引用，所以会打印函数体。
5. 执行到变量 a 赋值操作时，会将执行上下文中变量环境中的 a 的值更新为 hello world。

**如果当前作用域中存在同名的变量和函数，变量的声明会被忽略或者覆盖掉。**

### **执行上下文 - 调用栈**

全局代码、函数调用、eval函数执行时，会在编译后创建执行上下文，调用栈就是一种用来管理函数调用关系的数据结构。调用栈中存放执行上下文，又称执行上下文栈。

调用栈是用来追踪函数执行的一个机制，当函数调用层级很深时，通过调用栈查看当前执行函数及函数之间的调用关系。

### 块级作用域

**作用域：定义变量的访问范围，该位置决定变量的生命周期。ES6之前只有全局作用域和函数作用域，ES6有了 let, const 后就可以声明块级作用域了。**

有了块级作用域，更加符合编程习惯：作用域块内部的变量不会影响外部的变量。

JS是如何支持块级作用域的？

```text
function gen() {
  var a = 1
  let b = 2
  if (true) {
    var c = 3
    let b= 4
    let d = 5
  }
  console.log(b)
  console.log(c)
}
gen()
```

根据上述代码所示，首先会对代码进行编译生成AST，然后会创建执行上下文。gen 函数执行时：

1. 执行上下文的变量环境中有 a, c 变量，词法环境中有 b 变量。
2. 执行到 if 语句时，变量环境中的 a = 1、词法环境中 b = 2，由于语句内部存在 let 关键字会创建块级作用域，if语句中的作用域块会被存放到词法环境的一个单独的区域，区域内部不影响作用域外部的变量
3. 执行 console 时，会进行变量访问，首先从当前执行上下文中的词法环境自上往下查找，如果没有找到，继续从变量环境中查找。

#### 块级作用域内部存在临时性死区：let const 关键字声明的变量不能在声明前访问。

### 作用域链

执行上下文中，除了变量环境、词法环境外还有一个 outer 指针，outer 指向外部作用域。

词法作用域：根据代码的书写位置决定的。包含全局作用域、函数作用域、块级作用域。

在变量的查找过程中，首先在当前执行上下文的词法环境中查找，如果没有就会继续查找变量环境 ，然后会向 outer 指向的外部作用域的执行上下文中查找，这样的查找方式构成了一条链式结构就是作用域链。

### 闭包

什么是闭包？

**内部函数引用了外部函数中的变量，当调用外部函数并且执行完毕后，外部函数的执行上下文已经被销毁，但是内部函数引用的外部函数中的变量仍然存在内存中，把这些变量的集合称为闭包。**

闭包何时被销毁？

当这个变量的集合不被引用时，V8引擎的垃圾回收会自动回收掉。

